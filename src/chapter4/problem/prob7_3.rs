use proconio::input;

const MOD: usize = 1000000007;

// K=2 の場合の遷移
const MAT2: [[usize; 4]; 4] = [[0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 1]];

// K=3 の場合の遷移
const MAT3: [[usize; 8]; 8] = [
    [0, 0, 0, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 1, 0, 0, 1],
    [0, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 1, 0, 0, 1, 0],
];

// K=4 の場合の遷移
const MAT4: [[usize; 16]; 16] = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
    [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
];

fn main() {
    // 入力
    input! { k: usize, n: usize }
    // 行列 A の作成
    let mut a = vec![vec![0; 1 << k]; 1 << k];
    for i in 0..(1 << k) {
        for j in 0..(1 << k) {
            if k == 2 {
                a[i][j] = MAT2[i][j];
            }
            if k == 3 {
                a[i][j] = MAT3[i][j];
            }
            if k == 4 {
                a[i][j] = MAT4[i][j];
            }
        }
    }

    // B = A^N の計算
    let b = power(a, n, 1 << k);
    println!("{}", b[(1 << k) - 1][(1 << k) - 1]);
}

/**
 * s×s 行列 A, B の積を返す関数
 */
fn multiply(a: Vec<Vec<usize>>, b: Vec<Vec<usize>>, s: usize) -> Vec<Vec<usize>> {
    let mut c = vec![vec![0; s]; s];
    for i in 0..s {
        for j in 0..s {
            for k in 0..s {
                c[i][j] += a[i][k] * b[k][j];
                c[i][j] %= MOD
            }
        }
    }
    c
}

/**
 * A の n 乗を返す関数
 */
fn power(a: Vec<Vec<usize>>, n: usize, s: usize) -> Vec<Vec<usize>> {
    let mut p = a.clone();
    let mut q = vec![vec![0; s]; s];
    let mut flag = false;
    for i in 0..60 {
        if (n & (1 << i)) != 0 {
            if flag == false {
                q = p.clone();
                flag = true;
            } else {
                q = multiply(q, p.clone(), s).clone();
            }
        }
        p = multiply(p.clone(), p.clone(), s).clone();
    }
    q
}
